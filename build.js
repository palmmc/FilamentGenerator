// Build import manifest by discovering generator templates.

const fs = require("fs/promises");
const path = require("path");

// File path definitions
const projectRoot = path.resolve(process.cwd(), "public");
const GENERATORS_ROOT = path.resolve(process.cwd(), "public/generators");
const OUTPUT_FILE = path.resolve(process.cwd(), "public/manifest.js");

function color(color) {
  const colors = {
    red: 31,
    green: 32,
  };
  return `\x1b[${colors[color]}m`;
}

function resetColor() {
  return "\x1b[0m";
}

/**
 * Recursive discover directories.
 * @param {string} dir Directory to search in.
 * @returns {Promise<string[]>} List of file paths.
 */
async function getFiles(dir) {
  const dirents = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    dirents.map((dirent) => {
      const res = path.resolve(dir, dirent.name);
      return dirent.isDirectory() ? getFiles(res) : res;
    })
  );
  return Array.prototype.concat(...files);
}

async function generateManifest() {
  console.log("Discovering dependencies...");

  try {
    const allFiles = await getFiles(GENERATORS_ROOT);
    // Find groups
    const groupDirs = [
      ...new Set(
        allFiles
          .filter((file) => path.basename(file) === "group.json")
          .map((file) => path.dirname(file))
      ),
    ];

    const allImports = new Set();

    const groupData = [];
    for (const dir of groupDirs) {
      console.log(`- Processing group: ${path.basename(dir)}`);
      const groupJsonPath = path.join(dir, "group.json");
      const groupInfo = JSON.parse(await fs.readFile(groupJsonPath, "utf-8"));

      if (!groupInfo.enabled) {
        console.log(`- Skipping disabled group: ${groupInfo.name}`);
        continue;
      }

      // Include dependencies if there are any
      if (groupInfo.includeDependencies) {
        for (const depPath of groupInfo.includeDependencies) {
          const fullDepPath = path.resolve(projectRoot, depPath);
          try {
            const depContent = await fs.readFile(fullDepPath, "utf-8");
            const relativePath =
              "./" +
              path
                .relative(path.dirname(OUTPUT_FILE), fullDepPath)
                .replace(/\\/g, "/");

            // Find all exports in dependency
            const exportsMatches = [
              ...depContent.matchAll(
                /export\s+(?:const|let|var|class|function)\s+([^\s;(=]+)|export\s*{\s*([^}]+)\s*}/g
              ),
            ];
            const exportedSymbols = [];

            for (const match of exportsMatches) {
              if (match[1]) {
                exportedSymbols.push(match[1]);
              }
              if (match[2]) {
                exportedSymbols.push(
                  ...match[2].split(",").map((s) => s.trim().split(" as ")[0])
                );
              }
            }

            if (exportedSymbols.length > 0) {
              allImports.add(
                `import { ${exportedSymbols.join(
                  ", "
                )} } from '${relativePath}';`
              );
            }
            console.log("  Imported dependency:", relativePath);
          } catch (e) {
            throw new Error(
              `Invalid dependency:${resetColor()}\n   ${fullDepPath}\n    at: ${groupJsonPath}\n${e}`
            );
          }
        }
      }

      const templateFiles = (await fs.readdir(dir)).filter((f) =>
        f.endsWith(".js")
      );
      const templates = [];
      for (const file of templateFiles) {
        const filePath = path.join(dir, file);
        try {
          const fileContent = await fs.readFile(filePath, "utf-8");
          const classMatches = [
            ...fileContent.matchAll(/export\s+class\s+([a-zA-Z0-9_]+)/g),
          ];

          for (const match of classMatches) {
            const className = match[1];
            // Create relative path for import.
            const importPath =
              "./" +
              path
                .relative(path.dirname(OUTPUT_FILE), filePath)
                .replace(/\\/g, "/");

            allImports.add(`import { ${className} } from '${importPath}';`);
            templates.push({ name: className });
            console.log("  Loaded template:", importPath);
          }
        } catch (e) {
          throw new Error(
            `Failed to load template:${resetColor()}\n   ${filePath}\n    at: ${groupJsonPath}\n${e}`
          );
        }
      }

      groupData.push({
        name: groupInfo.name,
        templates: templates,
      });
    }

    // Generate manifest.
    let manifestContent = `// Manifest is automatically generated by build task. Do not modify manually.\n\n`;
    manifestContent += [...allImports].join("\n") + "\n\n";
    const templatesPath = path.resolve(projectRoot, "engine/templates.js");
    try {
      const fileContent = await fs.readFile(templatesPath, "utf-8");
      const classMatches = [
        ...fileContent.matchAll(/export\s+class\s+([a-zA-Z0-9_]+)/g),
      ];
      manifestContent += `import { ${classMatches
        .map((x) => x[1])
        .join(", ")} } from './engine/templates.js';\n\n`;
      console.log(`Imported required classes from ${templatesPath}`);
    } catch (e) {
      throw new Error(
        `Failed to required classes:${resetColor()}\n    at: ${templatesPath}\n${e}`
      );
    }

    manifestContent += `\n\nexport const generatorGroups = [\n`;
    groupData.forEach((group) => {
      manifestContent += `  {\n    name: "${group.name}",\n    templates: [\n`;
      group.templates.forEach((t) => {
        manifestContent += `      new ${t.name}(),\n`;
      });
      manifestContent += `    ]\n  },\n`;
    });
    manifestContent += "];\n\nexport const allTemplates = new Map([\n";
    groupData
      .flatMap((g) => g.templates)
      .forEach((t) => {
        manifestContent += `  [(new ${t.name}()).id, new ${t.name}()],\n`;
      });
    manifestContent += `]);\n\nexport {\n  BaseTemplate,\n  Field,\n  SelectField,\n  NumberField,\n  FileField,\n  ChildItem\n};\n`;

    await fs.writeFile(OUTPUT_FILE, manifestContent);
    console.log(
      `${color(
        "green"
      )}Manifest generation successful:${resetColor()} ${OUTPUT_FILE}`
    );
  } catch (error) {
    console.error(
      `${color("red")}Error during manifest generation:${resetColor()}`,
      error
    );
    process.exit(1);
  }
}

generateManifest();
